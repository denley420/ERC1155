// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

/* 
ERC1155
- Is ownable
- Each token ID needs to have a max supply of 1
- Token IDs will be 0, 1, 2, 3 but users can see 1, 2, 3 
- Each token should have its own baseURI, meaning I can have two NFTs with different baseURI
- URL for each token should be changeable by contract owner
- A new token can be minted by contract owner with input parameters: string uri
- Token ID is autogenerated and incremental
- Tokens should be minted to fixed address 'treasury'
- 'treasury' should be updatable by owner
*/

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract ERC1155Token is ERC1155, Ownable {
    uint maxSupply = 1;
    uint public tokenId = 0;
    address public treasury;

    mapping(uint => string) baseURI;

    constructor(address _treasury) ERC1155("") {
        treasury = _treasury;
    }

    function mint(string memory _uri) public onlyOwner {
        _mint(treasury, tokenId, maxSupply, "");
        baseURI[tokenId] = _uri;
        tokenId++;
    }

    function uri(uint256 _index) public view override returns (string memory) {
        require(_index <= tokenId);
        return string(
            abi.encodePacked(
                baseURI[_index - 1],
                Strings.toString(_index),
                '.json'
            )
        );
    }

    function changeURI(uint _index, string memory _newURI) public {
        baseURI[_index - 1] = _newURI;
    }

    function changeTreasury(address _newTreasury) public onlyOwner {
        treasury = _newTreasury;
    }
}