const { expect } = require("chai");
const { loadFixture } = require("ethereum-waffle");
const { ethers } = require("hardhat");

let contract;

describe("ERC1155", function () {
  beforeEach(async () => {
    const [_, acct1] = await ethers.getSigners();

    const ERC1155Token = await ethers.getContractFactory("ERC1155Token");
    contract = await ERC1155Token.deploy(acct1.address); // will pass an address treasury
    await contract.deployed();
  });

  // We define a fixture to reuse the same setup in every test.
  // We use loadFixture to run this setup once, snapshot that state,
  // and reset Hardhat Network to that snapshopt in every test.
  async function testFixture() {
    // Contracts are deployed using the first signer/account by default
    const [owner, acct1, acct2] = await ethers.getSigners();

    return { contract, owner, acct1, acct2 };
  }

  it("should be deployable (and set the right owner)", async function () {
    const { owner } = await loadFixture(testFixture);
    expect(await contract.owner()).to.equal(owner.address);
  });

  describe("Tokens", async function () {
    it("should be able to be minted only by owner and only takes URI", async function () {
      let { acct1 } = await loadFixture(testFixture);

      await contract.mint("http://asd.com/1.json");

      // Must fail. Only Owner can mint
      await expect(contract.connect(acct1).mint("http://asd.com/1.json")).to.be.reverted;

      // Must fail. No URI
      await expect(contract.mint()).to.be.reverted;
    });

    it("should track how many tokens were minted", async function () {
      await loadFixture(testFixture);

      expect(await contract.tokenId()).to.equal("0");
      await contract.mint("http://asd.com/1.json");
      expect(await contract.tokenId()).to.equal("1");
      await contract.mint("http://asd.com/2.json");
      expect(await contract.tokenId()).to.equal("2");
    });

    it("should acccept unique URI for each token", async function () {
      await loadFixture(testFixture);

      const baseURI1 = "http://asd1.com/";
      const baseURI2 = "http://asd2.com/";
      await contract.mint(baseURI1);
      await contract.mint(baseURI2);
      expect(await contract.uri("1")).to.equal(`${baseURI1}1.json`);
      expect(await contract.uri(2)).to.equal(`${baseURI2}2.json`);
    });

    it("URI should be changeable by owner", async function () {
      const { acct1 } = await loadFixture(testFixture);

      const baseURI1 = "http://asd1.com/";
      await contract.mint(baseURI1);
      expect(await contract.uri("1")).to.equal(`${baseURI1}1.json`);

      const baseURI3 = "http://asd3.com/";
      await contract.changeURI(1, baseURI3);
      expect(await contract.uri(1)).to.equal(`${baseURI3}1.json`);

      await expect(contract.connect(acct1).changeURI(0, "http://asd.com/")).to.be.reverted;
    });

    it("ID should be autogenerated and incremental", async function () {
      await loadFixture(testFixture); // Set-up

      // URL
      await contract.mint("http://asd.com");
      await contract.mint("http://asdfg.com");

      await expect(contract.uri("1")).to.not.be.reverted; // Mint #1 wont error
      await expect(contract.uri(2)).to.not.be.reverted; // Mint #2 wont error
      await expect(contract.uri(3)).to.be.reverted; // Mint #3 will error because its not minted yet
    });

    it("should be minted to the treasury address", async function () {
      const { acct1 } = await loadFixture(testFixture);

      const treasuryAddress = await contract.treasury();
      // Acct1 is the declared treasury of this contract when it was created.
      expect(treasuryAddress).to.equal(acct1.address);

      for (let i = 0; i < 5; i++) {
        // Treasury at first dont have the token
        expect(await contract.balanceOf(treasuryAddress, i)).to.equal("0");

        await contract.mint("asd");

        // ...and now it does
        expect(await contract.balanceOf(treasuryAddress, i)).to.equal("1");
      }
    });

    it("treasury should be updatable by owner", async function () {
      const { acct1, acct2 } = await loadFixture(testFixture);

      let treasuryAddress = await contract.treasury(); // Take acct1 treasury address
      // Acct1 is the declared treasury of this contract when it was created.
      expect(treasuryAddress).to.equal(acct1.address);

      for (let i = 0; i < 5; i++) {
        expect(await contract.balanceOf(treasuryAddress, i)).to.equal("0"); // Treasury at first dont have the token that's why it is set to 0

        await contract.mint("asd");

        // and now it does
        expect(await contract.balanceOf(treasuryAddress, i)).to.equal("1");
      }
      
      // We transfered the treasury to acct2 for newly minted tokens
      await contract.changeTreasury(acct2.address);
      treasuryAddress = await contract.treasury(); // Take acct2 treasury address
      expect(treasuryAddress).to.equal(acct2.address);

      // New tokens will be created to the new treasury
      for (let i = 5; i < 10; i++) {
        // Treasury at first dont have the token
        expect(await contract.balanceOf(treasuryAddress, i)).to.equal("0");

        await contract.mint("asd");

        // ...and now it does
        expect(await contract.balanceOf(treasuryAddress, i)).to.equal("1");
      }

      // Old tokens will stay in the old treasury
      for (let i = 0; i < 5; i++) {
        expect(await contract.balanceOf(acct1.address, i)).to.equal("1");
      }

      await expect(contract.connect(acct1).changeTreasury(acct2.address)).to.be.reverted; // Will promt error because it is not the owner
    });
  });

});